# 理解这个运行过程

* 涉及3个进程

进程1. go-docker进程本身,执行run命令

进程2. 通过/proc/self/exe启动的又一个go-docker进程(具有隔离ns的功能),执行init命令

进程3. 用户本来要在容器内启动的进程

进程3是通过进程2的init命令启动的，但是进程3会完全替换掉进程2的(堆栈,PID等)，最终只剩下进程1和进程3.

* init命令会做什么

1. 作为进程2挂载/proc

2. 启动进程3，并被进程2完全替换。(TODO:syscall.Exec的作用)

# 测试通过程序启动init命令，但是init只打印数据，不启动用户进程。

* 感受下在进程中调用另一个进程的过程

运行结果: 进程2不去启动进程3，只是打印一些东西。
