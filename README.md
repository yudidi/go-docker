# 理解这个运行过程

* 涉及3个进程和一次进程替换

进程1. go-docker进程本身,执行run命令

进程2. 通过/proc/self/exe启动的又一个go-docker进程(具有隔离ns的功能),执行init命令

进程3. 用户本来要在容器内启动的进程

进程3是通过完全替换进程2(堆栈,PID等)而得来的，所以最终只剩下进程1和进程3.

* [关于syscall.Exec](https://www.jianshu.com/p/e5855f6c1e29)

> `syscall.exec`会执行参数指定的命令,但是并不创建新的进程,只在当前进程空间内执行,即替换当前进程的执行内容,会重用同一个进程号`PID`.


* init命令会做什么

1. 作为进程2挂载/proc

2. 用进程3对进程2进行完全替换

# 测试通过程序启动init命令，但是init只打印数据，不启动用户进程。

* 感受下在进程中调用另一个进程的过程

运行结果: 进程2不去启动进程3，只是打印一些东西。
